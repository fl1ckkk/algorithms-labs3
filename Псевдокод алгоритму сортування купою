HeapSort (A)
// Вхідні дані: не відсортований масив A
// Вихідні дані: відсортований масив A

n ← |A|

// Фаза 1: Побудова максимальної купи
// Починаємо з першого елемента, що має дочірні вузли, і рухаємося до початку масиву.
for i ← floor((n / 2) – 1) down to 0 do
Sink(A, i, n)

// Фаза 2: Сортування
// Повторно вилучаємо максимальний елемент і переміщуємо його в кінець масиву.
for i ← n – 1 down to 1 do
Swap(A[0], A[i])
// Відновлюємо властивості купи для зменшеного масиву.
Sink(A, 0, i)

Sink(A, i, n)
// Вхідні дані: масив A, індекс кореня піддерева i, n – розмір купи
// Вихідні дані: масив A, де елемент А[i] занурився на потрібне місце

k ← i
while True do
j ← 2 * k + 1 // Індекс лівого дочірнього елемента

// Перевіряємо, чи існує лівий дочірній елемент
if j >= n then
    break

// Знаходимо індекс найбільшого дочірнього елемента
if j + 1 < n and A[j + 1] > A[j] then
    j ← j + 1

// Порівнюємо поточний елемент з найбільшим дочірнім
if A[k] >= A[j] then
    break // Елемент на своєму місці, вихід з циклу
else
    Swap(A[k], A[j])
    k ← j
